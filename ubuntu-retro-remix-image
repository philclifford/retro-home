#!/usr/bin/env bash
LC_ALL=C

# TODO
# - Add Plymouth splash
# - Add 'ludo' user authentication for Samba
# - Add Ludo icon to Slickgreeter
# - Add Ludo icon to .faces
# - Add a custom panel layout?
# - Add Vivaldi browser?
# - Integrate LudOS session with desktop session
# - Integrate Brisk Menu?
# - Disable GNOME suspend
# - Disable Tracker; via systemd unit
# - Disable TeXinfo icon

# Display help usage
function usage () {
  echo
  echo "Usage"
  echo "  $0 --remix <targetdevice> --img ubuntu-21.10-preinstalled-server-armhf+raspi.img"
  echo
  echo "Available supported devices are:"
  echo "  raspi"
  echo "  megapi"
  echo "  nespi"
  echo "  superpi"
}

function nspawn() {
    echo "nameserver 1.1.1.1" > "${TMP_DIR}/resolv.conf"

    # Make sure the container has a machine-id
    systemd-machine-id-setup --root "${R}" --print

    # Bind mount resolv.conf and the firmware, set the hostname and spawn
    systemd-nspawn \
      --resolv-conf=off \
      --bind-ro="${TMP_DIR}/resolv.conf":/etc/resolv.conf \
      --bind=${B}:/boot/firmware \
      --hostname="${REMIX}" \
      --machine="${REMIX}" \
      -D "${R}" "${@}"
}

function stage_00_tools() {
    # Required tools on the host
    apt-get -y install binfmt-support debootstrap \
    git qemu-user-static rsync systemd-container \
    ubuntu-keyring whois xz-utils
}

function stage_01_unpack() {
    # Capture the patition details.
    BOOT_PARTITION=$(fdisk -l "${IMG}" | grep "c W95 FAT32 (LBA)")
    ROOT_PARTITION=$(fdisk -l "${IMG}" | grep "83 Linux")
    echo "${BOOT_PARTITION}"
    echo "${ROOT_PARTITION}"

    # Grab the starting sector of the partitions.
    BOOT_START_SECTOR=$(echo "${BOOT_PARTITION}" | sed -e 's/\*//g' | awk '{print $2}')
    ROOT_START_SECTOR=$(echo "${ROOT_PARTITION}" | sed -e 's/\*//g' | awk '{print $2}')

    # Calculate the start byte of the partitions.
    ((BOOT_START_BYTE=BOOT_START_SECTOR * 512))
    ((ROOT_START_BYTE=ROOT_START_SECTOR * 512))

    BOOT_SECTOR_LENGTH=$(echo "${BOOT_PARTITION}" | sed -e 's/\*//g' | awk '{print $4}')
    ROOT_SECTOR_LENGTH=$(echo "${ROOT_PARTITION}" | sed -e 's/\*//g' | awk '{print $4}')

    # Calculate the byte length of the partitions.
    ((BOOT_BYTE_LENGTH=BOOT_SECTOR_LENGTH * 512))
    ((ROOT_BYTE_LENGTH=ROOT_SECTOR_LENGTH * 512))

    mkdir -p "${TMP_DIR}"/{boot,root}
    mkdir -p "${B}"
    mkdir -p "${R}"
    # Mount the partitions to the mount points.
    mount -v -o offset=${BOOT_START_BYTE},sizelimit=${BOOT_BYTE_LENGTH} -t vfat "${IMG}" "${TMP_DIR}/boot"
    mount -v -o offset=${ROOT_START_BYTE},sizelimit=${ROOT_BYTE_LENGTH} -t ext4 "${IMG}" "${TMP_DIR}/root"
    rsync -aHAXx --delete "${TMP_DIR}/boot/" "${B}/"
    rsync -aHAXx --delete "${TMP_DIR}/root/" "${R}/"
    umount -l "${TMP_DIR}/boot"
    umount -l "${TMP_DIR}/root"
    rm -rf "${TMP_DIR}/boot"
    rm -rf "${TMP_DIR}/root"
}

function stage_02_apt_remove() {
    # Depends
    nspawn apt -y purge --autoremove apport bcache-tools btrfs-progs byobu \
    cloud-guest-utils cloud-initramfs-copymods cloud-initramfs-dyn-netconf \
    curl dirmngr ethtool fonts-ubuntu-console git gnupg htop lvm2 mdadm \
    motd-news-config multipath-tools overlayroot patch pollinate screen \
    software-properties-common sosreport tmux update-notifier-common vim \
    xfsprogs

    # Recommends
    nspawn apt -y purge --autoremove fwupd landscape-common lxd-agent-loader \
    needrestart open-iscsi open-vm-tools snapd

    # The meta package
    nspawn apt -y purge --autoremove ubuntu-server

    nspawn apt -y update
    nspawn apt -y dist-upgrade
}

function stage_03_snap_remove() {
    # Remove existing seeded snaps.
    rm -v "${R}"/etc/systemd/system/snap-*.mount
    rm -v "${R}"/etc/systemd/system/snap.lxd.*
    rm -v "${R}"/etc/systemd/system/multi-user.target.wants/snap-*.mount
    rm -rfv "${R}"/snap/*
    rm -rfv "${R}"/var/lib/snapd/seed/*
    rm -fv "${R}"/var/lib/snapd/snaps/*.snap
    rm -fv "${R}"/var/lib/snapd/state.json
    rm -fv "${R}"/var/lib/snapd/system-key
}

function stage_04_network() {
    # nspawn systemctl stop \
    #     systemd-networkd.socket \
    #     systemd-networkd \
    #     networkd-dispatcher \
    #     systemd-networkd-wait-online

    # nspawn systemctl disable \
    #     systemd-networkd.socket \
    #     systemd-networkd \
    #     networkd-dispatcher \
    #     systemd-networkd-wait-online

    # nspawn systemctl disable systemd-resolved.service
    # nspawn systemctl stop systemd-resolved
    #nspawn apt -y purge --autoremove networkd-dispatcher
    #rm "${R}/etc/dhcp/dhclient-enter-hooks.d/resolved"

    nspawn apt -y purge --autoremove netplan.io

    # Disable cloud-init from managing the network
    echo "network: {config: disabled}" > "${R}/etc/cloud/cloud.cfg.d/99-disable-network-config.cfg"

    mkdir -p ${R}/etc/systemd/resolved.conf.d
    cat <<'EOM' > "${R}/etc/systemd/resolved.conf.d/resolved.conf"
# Create basic resolv.conf for bind mounting inside the container
[Resolve]
# Some examples of DNS servers which may be used for DNS= and FallbackDNS=:
# Cloudflare: 1.1.1.1 1.0.0.1 2606:4700:4700::1111 2606:4700:4700::1001
# Google:     8.8.8.8 8.8.4.4 2001:4860:4860::8888 2001:4860:4860::8844
# Quad9:      9.9.9.9 149.112.112.112 2620:fe::fe 2620:fe::9
DNS=1.1.1.1 1.0.0.1 2606:4700:4700::1111 2606:4700:4700::1001
FallbackDNS=9.9.9.9 149.112.112.112 2620:fe::fe 2620:fe::9
EOM

#     cat <<"EOM" > "${R}/etc/hosts"
# 127.0.0.1 localhost ubuntu

# # The following lines are desirable for IPv6 capable hosts
# ::1 ip6-localhost ip6-loopback
# fe00::0 ip6-localnet
# ff00::0 ip6-mcastprefix
# ff02::1 ip6-allnodes
# ff02::2 ip6-allrouters
# ff02::3 ip6-allhosts
# EOM
}

function stage_05_install_ludo() {
    nspawn apt -y install cloud-guest-utils cloud-initramfs-growroot \
    libraspberrypi0 libraspberrypi-bin pi-bluetooth raspi-config rpi-eeprom

    # linux-modules-extra-raspi was introduce in 21.10 (Impish)
    case ${REL_VER} in
        21.10) nspawn apt -y install linux-modules-extra-raspi;;
    esac

    # X11 and graphics stack
    nspawn apt -y install libegl1 libgles1 libgles2 libglfw3 libglvnd0 \
    libosmesa6 libvulkan1 libxvmc1 xserver-xorg

    # LudOS requirements
    nspawn apt -y install bluez connman samba

    local LUDO_VER="0.16.9"
    wget -qc "https://github.com/libretro/ludo/releases/download/v${LUDO_VER}/ludo_${LUDO_VER}-1_armhf.deb" -O "${R}/ludo.deb"
    nspawn apt -y install /ludo.deb
    rm -f "${R}/ludo.deb"

    sed -i s'|Icon=ludo|Icon=/usr/share/icons/hicolor/1024x1024/apps/ludo\.png|' "${R}/usr/share/applications/ludo.desktop"

    # Create LudOS xsession
    cat <<'EOM' > "${R}/usr/local/bin/ludos"
#!/usr/bin/env bash
export __GL_YIELD=USLEEP
export SDL_MOUSE_RELATIVE=0
#export DISPLAY=:0.0
#export WAYLAND_DISPLAY=wayland-0
exec /usr/bin/ludo -ludos
EOM
    chmod 755 "${R}/usr/local/bin/ludos"

    mkdir -p "${R}/usr/share/xsessions"
    cp -a "${R}/usr/share/applications/ludo.desktop" "${R}/usr/share/xsessions/ludos.desktop"
    sed -i 's|Exec=ludo|Exec=ludos|' "${R}/usr/share/xsessions/ludos.desktop"
    sed -i 's|Name=Ludo|Name=LudOS|' "${R}/usr/share/xsessions/ludos.desktop"

    # Display manager
    nspawn apt -y install --no-install-recommends lightdm slick-greeter

    #TODO!
    # Root login for the LudOS session - https://gist.github.com/intrd/12c12f6c863b3367f8c2249edd78b26c
    # Enable auto-login for 'ludo' user
    cat <<'EOM' > "${R}/etc/lightdm/lightdm.conf"
[SeatDefaults]
autologin-user=ludo
autologin-user-timeout=0
autologin-session=ludos
EOM

    # Create directories Ludo requires
    for DOT_DIR in .cache/connman .cache/services .config/ludo .local/ludo .ludo .update; do
        mkdir -p "${R}/storage/${DOT_DIR}"
    done

    for CONF_FILE in .cache/services/bluez.conf .cache/services/samba.conf .cache/services/sshd.conf; do
        touch "${R}/storage/${CONF_FILE}"
    done

    for LUDO_DIR in playlists roms savefiles savestates screenshots system thumbnails; do
        mkdir -p "${R}/storage/Retro/${LUDO_DIR}"
    done

    chown -Rv 1000:1000 "${R}/storage"

    cat <<'EOM' > "${R}/etc/ludo.toml"
video_fullscreen = true
cores_dir = "/usr/lib/ludo"
assets_dir = "/usr/share/ludo/assets"
database_dir = "/usr/share/ludo/database"
playlists_dir = "/storage/Retro/playlists"
savefiles_dir = "/storage/Retro/savefiles"
savestates_dir = "/storage/Retro/savestates"
screenshots_dir = "/storage/Retro/screenshots"
system_dir = "/storage/Retro/system"
thumbnail_dir = "/storage/Retro/thumbnails"
bluetooth_service = true
samba_service = true
ssh_service = true
EOM
}

function stage_06_install_desktop() {
    # Desktop
    #  - mutter-common provide gschema that prevent g-c-c from crashing
    nspawn apt -y install --no-install-recommends connman-gtk dconf-editor \
    gnome-control-center gnome-session-flashback file-roller fonts-mplus \
    indicator-applet indicator-application indicator-session \
    language-selector-gnome librsvg2-2 librsvg2-bin librsvg2-common \
    mutter-common pulseaudio sakura yaru-theme-sound

    cat <<'EOM' > "${R}/usr/share/applications/connman-gtk-flashback.desktop"
[Desktop Entry]
Type=Application
Exec=connman-gtk
Name=Connman Settings
Categories=GTK;Utility;System;
Keywords=connman;network;settings;wired;wifi;wi-fi;bluetooth;vpn;tethering
X-GNOME-Settings-Panel=connman-gtk
X-Unity-Settings-Panel=connman-gtk
Icon=preferences-system-network
EOM

    # Theme
    wget -c "https://github.com/Jannomag/Yaru-Colors/releases/download/21.04snap/Yaru-Colors_21.04.zip" -O "${TMP_DIR}/Yaru-Colors_21.04.zip"
    unzip -o "${TMP_DIR}/Yaru-Colors_21.04.zip" -d "${TMP_DIR}"
    mkdir -p "${R}/usr/share/backgrounds/" 2>/dev/null
    cp -a "${TMP_DIR}"/Wallpapers/Yaru-Pink.jpg "${R}/usr/share/backgrounds/"
    cp -a "${TMP_DIR}"/Icons/Yaru-Pink "${R}/usr/share/icons/"
    cp -a "${TMP_DIR}"/Themes/Yaru-Pink* "${R}/usr/share/themes/"
    cp -a "${R}/usr/share/icons/ubuntu-mono-light" "${R}/usr/share/icons/ubuntu-mono-pink"
    rm "${R}/usr/share/icons/ubuntu-mono-pink/*.cache"
    sed -i s'|Ubuntu-Mono-Light|Ubuntu-Mono-Pink|' "${R}/usr/share/icons/ubuntu-mono-pink/index.theme"
    sed -i s'|Inherits=Humanity|Inherits=Yaru-Pink,Humanity|' "${R}/usr/share/icons/ubuntu-mono-pink/index.theme"
    nspawn gtk-update-icon-cache /usr/share/icons/ubuntu-mono-pink/

    wget -qc "https://raw.githubusercontent.com/wimpysworld/ubuntu-retro-remix/master/.github/logo.svg" -O "${R}/usr/share/icons/hicolor/scalable/apps/ubuntu-retro-remix.svg"

    # Create gschema override
    cat <<'EOM' > "${R}/usr/share/glib-2.0/schemas/90_ubuntu-retro-remix.gschema.override"
[x.dm.slick-greeter]
background='/usr/share/backgrounds/Yaru-Pink.jpg'
background-color='#e920a3'
draw-grid=true
draw-user-backgrounds=false
enable-hidpi='auto'
font-name='M+ 1p Medium 11'
icon-theme-name='ubuntu-mono-pink'
high-contrast=false
show-hostname=true
#logo=''
onscreen-keyboard=false
#other-monitors-logo=''
play-ready-sound='/usr/share/sounds/Yaru/stereo/system-ready.oga'
screen-reader=false
show-power=true
show-a11y=false
show-keyboard=true
show-clock=true
show-quit=true
theme-name='Yaru-Pink-light'
xft-antialias=true
xft-dpi=96
xft-hintstyle='hintslight'
xft-rgba='rgb'

[org.gnome.desktop.background]
color-shading-type='vertical'
picture-uri='file:///usr/share/backgrounds/Yaru-Pink.jpg'
primary-color='#e920a3'
secondary-color='#742558'

[org.gnome.desktop.datetime]
automatic-timezone=true

[org.gnome.desktop.interface]
cursor-theme='Yaru'
document-font-name='M+ 1p Medium 11'
enable-hot-corners=false
font-name='M+ 1p Medium 11'
gtk-theme='Yaru-Pink-light'
icon-theme='ubuntu-mono-pink'
monospace-font-name='M+ 1mn Medium 14'

[org.gnome.desktop.lockdown]
disable-printing=true
disable-print-setup=true
disable-user-switching=true

[org.gnome.desktop.media-handling]
automount-open=false

[org.gnome.desktop.privacy]
remember-app-usage=false
remember-recent-files=false
report-technical-problems=false
send-software-usage-stats=false

[org.gnome.desktop.screensaver]
color-shading-type='vertical'
lock-enabled=false
picture-uri='file:///usr/share/backgrounds/Yaru-Pink.jpg'
primary-color='#e920a3'
secondary-color='#742558'
ubuntu-lock-on-suspend=false
user-switch-enabled=false

[org.gnome.desktop.session]
idle-delay=0

[org.gnome.desktop.sound]
theme-name='Yaru'

[org.gnome.desktop.wm.preferences]
button-layout=':minimize,maximize,close'
theme='Yaru-Pink-light'
titlebar-font='M+ 1p Bold 11'
titlebar-uses-system-font=false

[org.gnome.gnome-flashback.desktop.background]
fade=false

[org.gnome.gnome-flashback.desktop.icons]
show-home=false
show-trash=false

[org.gnome.metacity]
alt-tab-thumbnails=true

[org.gnome.metacity.theme]
name='Yaru-Pink-light'

[org.gnome.settings-deamon.plugins.power]
idle-dim=false
power-button-action='interactive'
sleep-inactive-ac-timeout=0
sleep-inactive-ac-type='nothing'
sleep-inactive-battery-timeout=0
sleep-inactive-battery-type='nothing'
EOM

    nspawn glib-compile-schemas /usr/share/glib-2.0/schemas/
}

function stage_07_system_config() {

    #TODO! Regenerate ssh key oneshot
    #https://askubuntu.com/questions/960927/how-to-generate-ssh-keys-before-the-ssh-daemon-does-for-the-first-time

    cat <<'EOM' > "${R}/etc/samba/smb.conf"
#
# Sample configuration file for the Samba suite for Ubuntu Retro Remix.
#
#
# You should read the smb.conf(5) manual page in order to understand the
# options listed here. Whenever you modify this file you should run the command
# "testparm" to check that you have not made any basic syntactic errors.

[global]
  server string = retro-remix
  browseable = yes
  writeable = yes
  printable = no
  deadtime = 30
  mangled names = no
  name resolve order = host bcast
  printcap name = /dev/null
  load printers = no
  encrypt passwords = true
  enable core files = no
  passdb backend = smbpasswd
  smb encrypt = disabled
  fruit:model = Xserve

  # samba share options
  map to guest = Bad User
  guest account = ludo
  security = user

  # samba tuning options
  socket options = TCP_NODELAY IPTOS_LOWDELAY
  min receivefile size = 16384
  aio read size = 16384
  aio write size = 16384
  use sendfile = yes

  # The following are default values for the master selection process
  # local master = yes
  # preferred master = auto
  # domain master = auto
  # os level = 20

  # "strict allocate = yes" breaks large network transfers to external hdd
  # Force this to "no" in case "yes" becomes the default in future
  strict allocate = no

  allocation roundup size = 0

# Using the following configurations as a template allows you to add
# writeable shares of disks and paths under /storage

[Update]
  path = /storage/.update
  available = yes
  browseable = yes
  public = yes
  writeable = yes
  root preexec = mkdir -p /storage/.update

[ROMs]
  path = /storage/Retro/roms
  available = yes
  browseable = yes
  public = yes
  writeable = yes
  root preexec = mkdir -p /storage/Retro/roms

[Savestates]
  path = /storage/Retro/savestates
  available = yes
  browseable = yes
  public = yes
  writeable = yes
  root preexec = mkdir -p /storage/Retro/savestates

[Savefiles]
  path = /storage/Retro/savefiles
  available = yes
  browseable = yes
  public = yes
  writeable = yes
  root preexec = mkdir -p /storage/Retro/savefiles

[Screenshots]
  path = /storage/Retro/screenshots
  available = yes
  browseable = yes
  public = yes
  writeable = yes
  root preexec = mkdir -p /storage/Retro/screenshots

[System]
  path = /storage/Retro/system
  available = yes
  browseable = yes
  public = yes
  writeable = yes
  root preexec = mkdir -p /storage/Retro/system

[Playlists]
  path = /storage/Retro/playlists
  available = yes
  browseable = yes
  public = yes
  writeable = yes
  root preexec = mkdir -p /storage/Retro/playlists

[Thumbnails]
  path = /storage/Retro/thumbnails
  available = yes
  browseable = yes
  public = yes
  writeable = yes
  root preexec = mkdir -p /storage/Retro/thumbnails
EOM

    cat <<EOM > "${B}/README"
An overview of the files on the /boot/firmware partition (the 1st partition
on the SD card) used by the Ubuntu boot process (roughly in order) is as
follows:

* bootcode.bin   - this is the second stage bootloader loaded by all pis with
                   the exception of the pi4 (where this is replaced by flash
                   memory)
* config.txt     - the configuration file read by the boot process
* start*.elf     - the third stage bootloader, which handles device-tree
                   modification and which loads...
* vmlinuz        - the Linux kernel
* cmdline.txt    - the Linux kernel command line
* initrd.img     - the initramfs
EOM

    cat <<EOM > "${B}/config.txt"
[pi4]
max_framebuffers=2

[all]
kernel=vmlinuz
cmdline=cmdline.txt
initramfs initrd.img followkernel

# Enable the audio output, I2C and SPI interfaces on the GPIO header
dtparam=audio=on
dtparam=i2c_arm=on
dtparam=spi=on

# Enable the full KMS graphics overlay, as recommended by Ludo
dtoverlay=vc4-kms-v3d
gpu_mem=128
start_x=1

# Comment out the following line if the edges of the desktop appear outside
# the edges of your display
disable_overscan=1

# If you have issues with audio, you may try uncommenting the following line
# which forces the HDMI output into HDMI mode instead of DVI (which doesn't
# support audio output)
hdmi_drive=2

# If you have a CM4, uncomment the following line to enable the USB2 outputs
# on the IO board (assuming your CM4 is plugged into such a board)
#dtoverlay=dwc2,dr_mode=host
EOM

    echo "net.ifnames=0 dwc_otg.lpm_enable=0 console=tty1 root=LABEL=writable rootfstype=ext4 elevator=deadline rootwait fixrtc quiet splash" > "${B}/cmdline.txt"

    # Create user and groups
    local DATE=""
    DATE=$(date +%m%H%M%S)
    local PASSWD=""
    PASSWD=$(mkpasswd -m sha-512 "test" "${DATE}")
    nspawn addgroup --gid 1000 ludo

    # Create Raspberry Pi specific groups.
    nspawn groupadd -f --system gpio
    nspawn groupadd -f --system i2c
    nspawn groupadd -f --system input
    nspawn groupadd -f --system spi

    cat <<'EOM' > "${R}/usr/local/sbin/adduser.local"
#!/bin/sh
# This script is executed as the final step when calling `adduser`
# USAGE:
#   adduser.local USER UID GID HOME

# Add user to the Raspberry Pi specific groups
usermod -a -G adm,gpio,i2c,input,spi,video $1
EOM
    chmod 755 "${R}/usr/local/sbin/adduser.local"

    nspawn adduser --gecos "Ludo" --add_extra_groups --disabled-password --home /storage --gid 1000 --uid 1000 ludo
    nspawn usermod -a -G adm,sudo -p "${PASSWD}" ludo

    cat <<'EOM' > "${R}/etc/fstab"
LABEL=writable      /               ext4    defaults,noatime,x-systemd.growfs   0   0
LABEL=system-boot   /boot/firmware  vfat    defaults                            0   1
EOM
}

function stage_08_clean() {
    nspawn apt-get -y update
    nspawn apt-get -y upgrade
    nspawn apt-get -y dist-upgrade
    nspawn apt-get -y autoremove
    nspawn apt-get -y autoclean
    nspawn apt-get -y clean

    # Remove old kernel
    local OLD_KERNEL=$(ls -1 ${R}/lib/modules/ | head -n1)
    local OLD_KERNEL_SHORT=$(echo "${OLD_KERNEL}" | sed s'/-raspi//')
    local NEW_KERNEL=$(ls -1 ${R}/boot/vmlinuz-* | tail -n1 | awk -F/ '{print $NF}' | cut -d'-' -f2-4)
    echo "Old: ${OLD_KERNEL} (${OLD_KERNEL_SHORT})"
    echo "New: ${NEW_KERNEL}"
    if [ "${OLD_KERNEL}" == "${NEW_KERNEL}" ]; then
        echo "No old kernel to remove."
    else
        nspawn apt -y remove "linux-image-${OLD_KERNEL}" "linux-modules-${OLD_KERNEL}" "linux-raspi-headers-${OLD_KERNEL_SHORT}"
        # linux-modules-extra-raspi was introduce in 21.10 (Impish)
        case ${REL_VER} in
            21.10) nspawn apt -y remove "linux-modules-extra-${OLD_KERNEL}";;
        esac
    fi

    # Copy new devicetree, overlays and kernel to /boot/firmware
    cp "${R}/lib/firmware/${NEW_KERNEL}/device-tree/*.dtb" "${B}/"
    cp "${R}/lib/firmware/${NEW_KERNEL}/device-tree/broadcom/*.dtb" "${B}"/
    cp "${R}/lib/firmware/${NEW_KERNEL}/device-tree/overlays/*" "${B}"/overlays/
    cp -av "${R}/boot/vmlinuz-${NEW_KERNEL}" "${B}/vmlinuz"
    cp -av "${R}/boot/initrd.img-${NEW_KERNEL}" "${B}/initrd.img"

    rm -f "${B}"/meta-data
    rm -f "${B}"/network-config
    rm -f "${B}"/user-data
    rm -f "${B}"/{*.bak,*.old}
    rm -f "${R}"/boot/{*.bak,*.old}
    rm -f "${R}"/etc/ssh/ssh_host_*_key*
    rm -f "${R}"/etc/apt/*.save
    rm -f "${R}"/etc/apt/sources.list.d/*.save
    rm -f "${R}"/var/log/apt/*
    rm -f "${R}"/var/log/alternatives.log
    rm -f "${R}"/var/log/dpkg.log
    rm -f "${R}"/var/log/fontconfig.log
    rm -rf "${R}"/tmp/*
    rm -f "${R}"/var/crash/*
    rm -f "${R}"/var/cache/debconf/*-old
    rm -f "${R}"/var/lib/dpkg/*-old
    [ -L "${R}"/var/lib/dbus/machine-id ] || rm -f "${R}"/var/lib/dbus/machine-id
    echo '' > "${R}"/etc/machine-id
}

function stage_09_image() {
    # Build the image file
    local SIZE_IMG=$(du -csh "${R}" | tail -n1 | cut -d'.' -f1)
    ((SIZE_IMG+=2))
    local SIZE_BOOT="256MiB"

    # Remove old images.
    rm -fv "${TMP_DIR}/${IMG_OUT}"

    # Create an empty file file.
    dd if=/dev/zero of="${TMP_DIR}/${IMG_OUT}" bs=1MB count=1
    dd if=/dev/zero of="${TMP_DIR}/${IMG_OUT}" bs=1MB count=0 seek=$(( SIZE_IMG * 1000 ))

    # Initialising: msdos
    parted -s "${TMP_DIR}/${IMG_OUT}" mktable msdos
    echo "Creating /boot/firmware partition"
    parted -a optimal -s "${TMP_DIR}/${IMG_OUT}" mkpart primary fat32 1 "${SIZE_BOOT}"
    echo "Creating / partition"
    parted -a optimal -s "${TMP_DIR}/${IMG_OUT}" mkpart primary ext4 "${SIZE_BOOT}" 100%
    echo "Making partition 1 bootable"
    parted -s "${TMP_DIR}/${IMG_OUT}" set 1 boot on

    PARTED_OUT=$(parted -s "${TMP_DIR}/${IMG_OUT}" unit b print)
    BOOT_OFFSET=$(echo "${PARTED_OUT}" | grep -e '^ 1'| xargs echo -n \
    | cut -d" " -f 2 | tr -d B)
    BOOT_LENGTH=$(echo "${PARTED_OUT}" | grep -e '^ 1'| xargs echo -n \
    | cut -d" " -f 4 | tr -d B)

    ROOT_OFFSET=$(echo "${PARTED_OUT}" | grep -e '^ 2'| xargs echo -n \
    | cut -d" " -f 2 | tr -d B)
    ROOT_LENGTH=$(echo "${PARTED_OUT}" | grep -e '^ 2'| xargs echo -n \
    | cut -d" " -f 4 | tr -d B)

    BOOT_LOOP=$(losetup --show -f -o "${BOOT_OFFSET}" --sizelimit "${BOOT_LENGTH}" "${TMP_DIR}/${IMG_OUT}")
    ROOT_LOOP=$(losetup --show -f -o "${ROOT_OFFSET}" --sizelimit "${ROOT_LENGTH}" "${TMP_DIR}/${IMG_OUT}")
    echo "/boot/firmware: offset ${BOOT_OFFSET}, length ${BOOT_LENGTH}"
    echo "/:              offset ${ROOT_OFFSET}, length ${ROOT_LENGTH}"

    mkfs.vfat -n system-boot -S 512 -s 16 -v "${BOOT_LOOP}"
    mkfs.ext4 -L writable -m 0 "${ROOT_LOOP}"

    MOUNTDIR="${TMP_DIR}/image"
    mkdir -p "${MOUNTDIR}"
    mount -v "${ROOT_LOOP}" "${MOUNTDIR}" -t ext4
    mkdir -p "${MOUNTDIR}/boot/firmware"
    mount -v "${BOOT_LOOP}" "${MOUNTDIR}/boot/firmware" -t vfat
    echo "Syncing root..."
    rsync -aHAXx --delete "${R}"/ "${MOUNTDIR}/"
    echo "Syncing boot..."
    rsync -aHAXx --delete "${B}"/ "${MOUNTDIR}/boot/firmware/"
    date +"%Y%m%d" > "${MOUNTDIR}/.disk/info"
    sync
    umount -l "${MOUNTDIR}/boot/firmware"
    umount -l "${MOUNTDIR}"
    losetup -d "${ROOT_LOOP}"
    losetup -d "${BOOT_LOOP}"
    ls -lh "${TMP_DIR}/${IMG_OUT}"
    rm -rf "${MOUNTDIR}"

    # NOTE! Disabled while iterating
    echo "Compressing ${IMG_OUT}.xz"
    rm "${TMP_DIR}/${IMG_OUT}.xz" 2>/dev/null
    xz --keep -T 0 "${TMP_DIR}/${IMG_OUT}"
    ls -lh "${TMP_DIR}/${IMG_OUT}.xz"
}

function stage_08_hash() {
    local HASH="sha256"
    local OUT_HASH="${TMP_DIR}/${IMG_OUT}.xz.${HASH}"

    rm -f "${OUT_HASH}"

    if [ -e "${TMP_DIR}/${IMG_OUT}.xz" ]; then
        echo "Hashing ${IMG_OUT}.xz"
        ${HASH}sum "${TMP_DIR}/${IMG_OUT}.xz" > "${OUT_HASH}"
        sed -i -r "s/ .*\/(.+)/  \1/g" "${OUT_HASH}"
    else
        echo "WARNING! Didn't find ${TMP_DIR}/${IMG_OUT} to hash."
    fi
}

if [ "$(id -u)" -ne 0 ]; then
    echo "ERROR! Root permissions required."
    exit 1
fi

# Take command line arguments
if [ $# -lt 1 ]; then
    usage
    exit 0
else
    while [ $# -gt 0 ]; do
        case "${1}" in
            -remix|--remix)
                REMIX="${2}"
                shift
                shift;;
            -img|--img)
                IMG="${2}"
                if [ ! -e "${IMG}" ]; then
                    echo "[!] ERROR: ${IMG} was not found."
                    exit 1
                fi
                shift
                shift;;
            *)
                echo "[!] ERROR: \"${1}\" is not a supported parameter."
                usage
                exit 1;;
        esac
    done
fi

# Set variables based on chosen desktop environment
case "${REMIX}" in
    raspi)
        echo "[+] Specified Raspi"
        shift;;
    nespi)
        echo "[+] Specified NESPi"
        shift;;
    superpi)
        echo "[+] Specified SUPERPi"
        shift;;
    megapi)
        echo "[+] Specified MEGA Pi"
        shift;;
    *)
        if [ -z "${REMIX}" ]; then
        echo "[!] ERROR: Please specifiy an retro remix"
        else
        echo "[!] ERROR: ${REMIX} is not a valid retro remix"
        fi
        usage
        exit 1;;
esac

TMP_DIR=$(pwd)
IMG_QUALITY="-alpha1"
IMG_VER=$(echo "${IMG}" | cut -d'-' -f2)
IMG_ARCH=$(echo "${IMG}" | cut -d'+' -f1 | cut -d'-' -f5)
IMG_OUT=$(echo "${IMG}" | sed "s/ubuntu-/ubuntu-retro-${REMIX}-remix-/" | sed "s/preinstalled-server-//" | sed "s/${IMG_VER}/${IMG_VER}${IMG_QUALITY}/" | sed "s/\+raspi//")
IMG_TEST=$(file -b "${IMG}" | cut -d';' -f1)
B="${TMP_DIR}/${IMG_ARCH}/${REMIX}/boot"
R="${TMP_DIR}/${IMG_ARCH}/${REMIX}/root"

if [ "${IMG_TEST}" == "DOS/MBR boot sector" ]; then
    #stage_00_tools
    stage_01_unpack
    stage_02_apt_remove
    stage_03_snap_remove
    stage_04_network
    stage_05_install_ludo
    stage_06_install_desktop
    stage_07_system_config
    stage_08_clean
    stage_09_image
    #stage_10_hash
else
    echo "[!] ERROR: ${IMG} is not a valid disk image."
    if [ "${IMG_TEST}" == "XZ compressed data" ]; then
        echo "           Try decompressing ${IMG} first using:"
        echo "           unxz --decompress --keep ${IMG}"
    fi
    exit 1
fi
